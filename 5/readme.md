**Task 1: Advanced Array Filtering**
Create a function called customFilterUnique that takes an array and a callback function as arguments. The customFilterUnique function should filter the array using the callback function to determine uniqueness. The resulting array should contain only unique elements based on the callback's logic.
Use the customFilterUnique function to filter an array of objects based on a specific property and return only unique objects.<br>

**Task 2: Array Chunking**
Create a function called chunkArray that takes an array and a chunk size as arguments. The chunkArray function should divide the array into smaller arrays, each containing elements of the specified chunk size. The function should return an array of arrays.
Optimize the chunkArray function to minimize memory usage while chunking the array.<br>

**Task 3: Array Shuffling**
Create a function called customShuffle that takes an array as an argument and returns a new array with its elements randomly shuffled.
Implement the customShuffle function using an efficient shuffling algorithm to achieve uniform randomness.<br>

**Task 4: Array Intersection and Union**
Create a function called getArrayIntersection that takes two arrays as arguments and returns a new array containing the common elements between the two arrays.
Create a function called getArrayUnion that takes two arrays as arguments and returns a new array containing all unique elements from both arrays, without any duplicates.<br>

**Task 5: Array Performance Analysis**
Implement a function called measureArrayPerformance that takes a function and an array as arguments. The measureArrayPerformance function should execute the provided function with the given array as input and measure the execution time.
Use the measureArrayPerformance function to compare the performance of built-in array methods (map, filter, reduce, etc.) against your custom array manipulation functions.<br>